#!/usr/bin/env ruby
# frozen_string_literal: true

# MCP server for querying CodebaseIndex extraction output.
#
# Usage:
#   codebase-index-mcp [INDEX_DIR]
#   CODEBASE_INDEX_DIR=/path/to/output codebase-index-mcp
#
# Reads JSON files from the extraction output directory and exposes
# them via the Model Context Protocol (stdio transport).
# Does NOT require Rails â€” only reads pre-extracted data.

require_relative '../lib/codebase_index'
require_relative '../lib/codebase_index/dependency_graph'
require_relative '../lib/codebase_index/graph_analyzer'
require_relative '../lib/codebase_index/mcp/server'
require_relative '../lib/codebase_index/embedding/text_preparer'
require_relative '../lib/codebase_index/embedding/indexer'

index_dir = ARGV[0] || ENV['CODEBASE_INDEX_DIR'] || Dir.pwd

unless Dir.exist?(index_dir)
  warn "Error: Index directory does not exist: #{index_dir}"
  exit 1
end

unless File.exist?(File.join(index_dir, 'manifest.json'))
  warn "Error: No manifest.json found in: #{index_dir}"
  warn 'Run `bundle exec rake codebase_index:extract` in your Rails app first.'
  exit 1
end

# Attempt to build a retriever for semantic search.
# Auto-configures from environment variables when no explicit configuration exists.
retriever = begin
  config = CodebaseIndex.configuration

  if !config.embedding_provider && ENV.fetch('OPENAI_API_KEY', nil)
    config.vector_store = :in_memory
    config.metadata_store = :in_memory
    config.graph_store = :in_memory
    config.embedding_provider = :openai
    config.embedding_options = { api_key: ENV.fetch('OPENAI_API_KEY', nil) }
  end

  CodebaseIndex::Builder.new(config).build_retriever if config.embedding_provider
rescue StandardError => e
  warn "Note: Semantic search unavailable (#{e.message}). Using pattern-based search only."
  nil
end

server = CodebaseIndex::MCP::Server.build(index_dir: index_dir, retriever: retriever)

# Pin protocol version for broad client compatibility (Claude Code, Cursor, etc.)
if ENV['MCP_PROTOCOL_VERSION']
  server.configuration = MCP::Configuration.new(protocol_version: ENV['MCP_PROTOCOL_VERSION'])
end

transport = MCP::Server::Transports::StdioTransport.new(server)
transport.open
